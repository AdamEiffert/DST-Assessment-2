---
title: "01-Introduction and Data Formatting"
output: html_document
---

## The brief

The brief was to:

* Choose a goal for our analysis.
* choose a baseline model to compare our complex model to.
* Stratergise how to optimise the parameters of our complex model
* Use a strategy to analyse performance
* Compare the performance of the baseline to the complex model

We decided that we would stick with a simple goal of classifying if a packet was malicious or not as we looked to do more work in other aspects of the project. We decided to use a ... model as our baseline model because ... . We chose to use K-fold cross validation as this is effective while being simple to use. We decided to use the metric of ... to analyse our models. 

## Library requirements

```{r}
if (!require("R.utils")) install.packages("R.utils")
library("R.utils")
if (!require("data.table")) install.packages("data.table")
library("data.table")
if (!require("googledrive")) install.packages("googledrive")
library("googledrive")
if (!require("dplyr")) install.packages("dplyr")
library("dplyr")
if (!require("foreach")) install.packages("foreach")
library(foreach)
if (!require("doSNOW")) install.packages("doSNOW")
library(doSNOW)
if (!require("caret")) install.packages("caret")
library(caret)
if (!require("mltools")) install.packages("mltools")
library(mltools)
```


## The data

We each started by searching out a dataset of connections along with a snort log of another dataset, of which the connections log was a subset. 

To obtain this dataset in a convenient format, we will download it and, if necessary, process it into a standard form.

We place data in the raw or processed folder depending on the stage of processing, both of which are in the `data` folder of our root. So our file system will look like this:

* /data
  * /data/processed
    * /data/processed/snort.csv
    * /data/processed/labelled.csv
  * /data/raw
    * /data/raw/conn.log

### Create Folders
```{r}
if (!dir.exists('../data')) dir.create('../data')
if (!dir.exists('../data/raw')) dir.create('../data/raw')
if (!dir.exists('../data/processed')) dir.create('../data/processed')
```

### Download the data
```{r}
# if (!file.exists('../data/processed/conn.log'))
if (!file.exists('../data/raw/conn.log.gz') && !file.exists('../data/raw/conn.log')) {
  download.file('https://www.secrepo.com/maccdc2012/conn.log.gz', '../data/raw/conn.log.gz')
}
if (!file.exists('../data/raw/conn.log')) gunzip('../data/raw/conn.log.gz')
conn <- fread('../data/raw/conn.log', colClasses=list(character=1))
names(conn) = c("ts","uid","srcIP","srcPort","dstIP","dstPort","proto","service","duration","orig_bytes","resp_bytes","conn_state","local_orig","missed_bytes","history","orig_pkts","orig_ip_bytes","resp_pkts","resp_ip_bytes","tunnel_parents")
```

```{r}
if (!file.exists('../data/processed/snort.csv')) {
  drive_deauth()
  drive_download(as_id("1yx3enHgjRS234E6giO-88qSMoGiJndBo"), path = "../data/processed/snort.csv", overwrite = TRUE)
}
snort <- fread('../data/processed/snort.csv', colClasses=c("ts"="character"))
``` 

### Matching snort to conn
First, we select a random sample of 200,000 data points. This was limited by the time taken to label the data using the snort logs. The original plan was to label all of the conn.log data, however this was unfeasible time-wise even with multiple optimisations in place.
```{r}
set.seed(56)
random_sample1 <- conn[sample(1:nrow(conn),200000),]
```

Now for each of the snort log entries, we check to see if any entries in our random sample match, in which case they are labelled at malicious and their attack type is noted. Here we used the criteria of time, src and dst IP addresses and (if available) src and dst Ports. 
```{r}
cl <- makeCluster(8, type="SOCK") # for 8 cores machine
registerDoSNOW (cl)

for (j in c(1:nrow(snort))){
  if (snort$Port[j]){
    random_sample1[random_sample1$ts == snort$ts[j] & random_sample1$srcIP == snort$srcIP[j] & random_sample1$dstIP == snort$dstIP[j] & random_sample1$srcPort == snort$srcPort[j] & random_sample1$dstPort == snort$dstPort[j], ':=' ('malicious'=TRUE,'atcktype'=snort$type[j])]
  }else{
    random_sample1[random_sample1$ts == snort$ts[j] & random_sample1$srcIP == snort$srcIP[j] & random_sample1$dstIP == snort$dstIP[j],':=' ('malicious'=TRUE,'atcktype'=snort$type[j])]
  }
}
```
We now save this random sample to a file.
```{r}
write.csv(random_sample1,'../data/processed/labelled.csv')
```


### One-hot encoding
First, we read in the sample data, ignoring the indexing column.
```{r}
random_sample1 = fread('../data/processed/labelled.csv', colClasses=list(character=2))[,- 1]
```

We now look at each column to see if their typing is correct and if the column can be removed because they either do not have value for the analysis (uid) or only have one value (local_orig).
```{r}
random_sample1 <- random_sample1[, ':=' (uid=NULL,duration=as.numeric(duration),orig_bytes=as.numeric(orig_bytes),resp_bytes=as.numeric(resp_bytes),local_orig=NULL,tunnel_parents=NULL,atcktype=NULL)]
```
We now check for the categorical variable, which are those with type of character but are not the columns ts, srcIP and dstIP. Ideally, we would have wanted to one-hot encode the IP addresses as well, however this makes the table too big to store in R so we chose a different method, which will be seen later.
```{r}
categ={}
categoricals <- random_sample1[,sapply(.SD,is.character)]
for (i in 1:length(categoricals)){
  if (categoricals[i]){
    categ <- c(categ,i)
  }
}
categ <- categ[- 1]
categ <- categ[- 1]
categ <- categ[- 1]
```

We now create a table with columns with the one-hot encoding of the categorical variables.
```{r}
dummy <- dummyVars(" ~ .",data=random_sample1[,.SD,.SDcols=c(categ)])
random_sample <- data.table(predict(dummy,newdata = random_sample1[,.SD,.SDcols=c(categ)]))
```

We then merged the one-hot encoding with the main sample table.
```{r}
random_sample$id = 1:nrow(random_sample)
random_sample1$id = 1:nrow(random_sample1)
random_sample1 = merge(random_sample1,random_sample,by.x='id',by.y = 'id') [,- 1]
random_sample1 = random_sample1[,-c('proto','service','conn_state','history')]
```

Here we set all the Nas to 0 and change the malicious column to mal which uses 1 to represent malicious == TRUE and 0 otherwise. These are for xgboost to work.
```{r}
random_sample1$ts = as.numeric(random_sample1$ts)
random_sample1$duration[is.na(random_sample1$duration)] = 0
random_sample1$orig_bytes[is.na(random_sample1$orig_bytes)] = 0
random_sample1$resp_bytes[is.na(random_sample1$resp_bytes)] = 0
random_sample1$mal[random_sample1$malicious] = 1
random_sample1$malicious = NULL
```

```{r}
random_sample1[1]
```

```{r}
write.csv(random_sample1,'../data/processed/labelled1.csv')
```
https://doi.org/10.25394/PGS.11307287.v1
